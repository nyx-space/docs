# Module `anise.rotation` {#anise.rotation}

    
## Classes

    
### Class `DCM` {#anise.rotation.DCM}

>     class DCM(
>         np_rot_mat,
>         from_id,
>         to_id,
>         np_rot_mat_dt=None
>     )

Defines a direction cosine matrix from one frame ID to another frame ID, optionally with its time derivative.
It provides a number of run-time checks that prevent invalid rotations.

:type np_rot_mat: numpy.array
:type from_id: int
:type to_id: int
:type np_rot_mat_dt: numpy.array, optional
:rtype: DCM

    
#### Instance variables

    
##### Variable `from_id` {#anise.rotation.DCM.from_id}

:rtype: int

    
##### Variable `rot_mat` {#anise.rotation.DCM.rot_mat}

:rtype: numpy.array

    
##### Variable `rot_mat_dt` {#anise.rotation.DCM.rot_mat_dt}

:rtype: numpy.array

    
##### Variable `to_id` {#anise.rotation.DCM.to_id}

:rtype: int

    
#### Methods

    
##### Method `from_identity` {#anise.rotation.DCM.from_identity}

>     def from_identity(
>         from_id,
>         to_id
>     )

Builds an identity rotation.

:type from_id: int
:type to_id: int
:rtype: DCM

    
##### Method `from_r1` {#anise.rotation.DCM.from_r1}

>     def from_r1(
>         angle_rad,
>         from_id,
>         to_id
>     )

Returns a rotation matrix for a rotation about the X axis.

Source: <code>euler1</code> function from Baslisk

:type angle_rad: float
:type from_id: int
:type to_id: int
:rtype: DCM

    
##### Method `from_r2` {#anise.rotation.DCM.from_r2}

>     def from_r2(
>         angle_rad,
>         from_id,
>         to_id
>     )

Returns a rotation matrix for a rotation about the Y axis.

Source: <code>euler2</code> function from Basilisk

:type angle_rad: float
:type from_id: int
:type to_id: int
:rtype: DCM

    
##### Method `from_r3` {#anise.rotation.DCM.from_r3}

>     def from_r3(
>         angle_rad,
>         from_id,
>         to_id
>     )

Returns a rotation matrix for a rotation about the Z axis.

Source: <code>euler3</code> function from Basilisk

:type angle_rad: float
:type from_id: int
:type to_id: int
:rtype: DCM

    
##### Method `get_state_dcm` {#anise.rotation.DCM.get_state_dcm}

>     def get_state_dcm(
>         self,
>         /
>     )

Returns the 6x6 DCM to rotate a state. If the time derivative of this DCM is defined, this 6x6 accounts for the transport theorem.
Warning: you MUST manually install numpy to call this function.
:rtype: numpy.array

    
##### Method `is_identity` {#anise.rotation.DCM.is_identity}

>     def is_identity(
>         self,
>         /
>     )

Returns whether this rotation is identity, checking first the frames and then the rotation matrix (but ignores its time derivative)

:rtype: bool

    
##### Method `is_valid` {#anise.rotation.DCM.is_valid}

>     def is_valid(
>         self,
>         /,
>         unit_tol,
>         det_tol
>     )

Returns whether the <code>rot\_mat</code> of this DCM is a valid rotation matrix.
The criteria for validity are:
-- The columns of the matrix are unit vectors, within a specified tolerance (unit_tol).
-- The determinant of the matrix formed by unitizing the columns of the input matrix is 1, within a specified tolerance. This criterion ensures that the columns of the matrix are nearly orthogonal, and that they form a right-handed basis (det_tol).
[Source: SPICE's rotation.req](https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/req/rotation.html#Validating%20a%20rotation%20matrix)

:type unit_tol: float
:type det_tol: float
:rtype: bool

    
##### Method `transpose` {#anise.rotation.DCM.transpose}

>     def transpose(
>         self,
>         /
>     )

Returns the transpose of this DCM

:rtype: DCM

-----
Generated by *pdoc* 0.11.6 (<https://pdoc3.github.io>).
